# RedX

RedX is is an experimental cryptographic, deterministic, keyed **path-walking** cipher.

It walks a keyed 2D permutation grid, using a Blake3-driven jump stream to move the cursor, and emits a **key-row offset stream** as ciphertext. Decryption replays the same walk to recover plaintext.

RedX ships in two modes:

- **Symmetric mode**: full-key encrypt and decrypt.
- **Mint and Verify mode**: an origin-locked mode where a **minting key** produces ciphertext and a **verifier key** can decrypt and verify provenance, while the verifier key is intentionally unable to mint ciphertext that passes verification.

## Status

This is an experimental construction.

- No formal security proof.
- Not positioned as a drop-in replacement for AES or ChaCha.
- Published to invite analysis, including attempts to develop distinguishers and practical attacks.

## Core Ideas

### Keyed permutation grid

A full key is `keyBlockSize` rows of 256 bytes each.

- Each row is a Fisher–Yates shuffle of the byte values 0..255.
- Rows are concatenated into `keyBytes`.
- An inverse table `rkd[row][byte] -> column` is maintained for fast lookup.

### Jump stream

A Blake3-derived generator emits 16-bit jumps (`NextJump16`).

- High byte selects a row delta modulo `keyBlockSize`.
- Low byte selects a column delta modulo 256.

### Distance encoding

For each plaintext byte, the walker:

1. Applies a jump to move `(row, col)` within the RedX key.
2. Finds the column where the current plaintext byte appears in that row.
3. Emits the **forward wrapped distance** from the current column to that target column.
4. Advances to the target column and increments the row.

Ciphertext is the stream of these distance bytes emitted by step #3.

### Ciphertext as an action stream

A useful mental model is that ciphertext bytes are **actions** (relative movements) emitted from a keyed state machine. They are not “transformed plaintext values.”

Below is a vertical sketch focused on **what happens** (not how). Time increases upward.

- The **SECRET** column is the hidden cursor state (the landing position after the jump).
- The **CIPHER** column is what appears on the wire: a symbol plus the corresponding **distance** (forward wrapped steps) from that landing position.

```text
(time / byte index increases upward)
                ▲

PLAIN      SECRET           CIPHER (distance from landing position)
─────      ──────           ─────────────────────────────────────

  C        land(r,c)  ───►    #    (0xE1, 225 steps)
  ▲          ▲                 ▲
  │          │                 │
  B        land(r,c)  ───►    j    (0x03,   3 steps)
  ▲          ▲                 ▲
  │          │                 │
  A        land(r,c)  ───►    2    (0x11,  17 steps)

(seeded by key + startLoc + intCat)
```

Key point: the wire byte is the **distance / step count** (`0xNN`) to advance from the current secret landing position to the column of the next mixed plaintext byte. Without the keyed walk state, these distances are not directly interpretable as value transformations.

### Interference catalyst

A per-message byte array called the **interference catalyst** (`intCat`) is a random-length quantity of random bytes carried in the ciphertext header.

- Encrypt side: `plain = (plain + i + intCat[i % intCatLen]) mod 256`
- Decrypt side: `plain = (plain - i - intCat[i % intCatLen]) mod 256`

`intCat` has a few distinct roles in RedX (all of which matter):

1. **Ciphertext length variability**: it introduces a variable-length header contribution so ciphertext length is not equal to plaintext length.
2. **Per-message walk diversification**: it is fed into the jump generator, causing the path-walk to differ per message even under the same key.
3. **Index-dependent payload mixing**: it perturbs each payload byte by its position `i` and the catalyst byte, so the same plaintext value at different positions maps differently.
4. **Payload boundary obscuring**: because `intCatLen` varies and the catalyst bytes are present early in the encrypted header, it becomes harder to infer where the payload begins from structure alone.

`intCat` is also included in the optional integrity seal computation.

## Integrity seal

When enabled, RedX appends an encrypted integrity seal to the ciphertext.

- Seal length: **32 bytes (256 bits)** in the current implementation.
- Seal material: `integritySeal32B = Blake3(rowOffsetStream || intCat)`.
- The seal bytes are appended **in mapped (encrypted) form**.

Decryption recomputes the expected seal and compares it to the decrypted seal. If the integrity check fails, decryption returns `null` (no partial/garbled output).

This provides tamper and corruption detection with a fail-closed decryption behavior: modified ciphertext is rejected before any plaintext is released.

## Modes

RedX exposes two encryption modes with different key material and verification guarantees.

### Symmetric mode

- Uses a full `RedXKey` to encrypt and decrypt.
- Suitable for single-domain use where the decryptor can also mint ciphertext.

### Mint and Verify mode

- Uses a `RedXMintingKey` to mint ciphertext and a `RedXVerifierKey` to verify and decrypt.
- Verifier keys can decrypt and validate authority checkpoints but cannot mint ciphertext that verifies.
- Intended for origin-locking and provenance enforcement.

## Key Types

### `RedXKey`

Full key used for symmetric mode and for deriving verifier keys.

- Holds the permutation rows (`keyBytes`), inverse rows (`rkd`), and a 64-byte Blake3 digest of the key bytes (`keyHash`).

### `RedXMintingKey`

Minting composite key.

- Contains a `RedXKey` plus an **authority** ECDSA P-256 keypair (private PKCS#8 + public SPKI).
- Can mint signed ciphertext and derive a verifier key.

### `RedXVerifierKey`

Verifier composite key.

- Contains a verifier decryption key plus the **authority public key** (SPKI).
- Can verify provenance and decrypt Mint and Verify ciphertext.

### Verifier decryption key internals

The verifier decryption key is derived from a full key but does not retain the permutation bytes.

It stores:

- `keyHash` (64 bytes)
- `nonces[flatIndex]` (ushort per index)
- `map[h32] -> byte` where `h32 = Blake3(keyHash[0..8] || index || nonce) truncated to 32 bits`

This supports decryption by lookup without exposing the full permutation.



## Quick Start

### Symmetric encrypt and decrypt

```csharp
using RedxLib;
using System.Text;

var key = RedX.CreateKey();
var plaintext = Encoding.UTF8.GetBytes("hello");

using var cipher = RedX.Encrypt(plaintext, key);
using var recovered = RedX.Decrypt(cipher, key);

var text = Encoding.UTF8.GetString(recovered.AsReadOnlySpan);
```

### Mint and Verify encrypt then verify and decrypt

```csharp
using RedxLib;
using System.Text;

var (minting, verifier) = RedX.CreateMintingKeyPair();
var data = Encoding.UTF8.GetBytes("hello");

using var cipher = RedX.Mint(data, minting);
using var recovered = RedX.VerifyAndDecrypt(cipher, verifier);

var text = Encoding.UTF8.GetString(recovered.AsReadOnlySpan);
```

## Wire Layout

### Symmetric mode layout

Symmetric ciphertext is:

- `enc(startLocation1Bit)`
- `enc(intCatLen)`
- `enc(intCat)`
- `rowOffsetStream`
- optional: `enc(integritySeal32B)`

Where `enc(...)` means RedX mapping using the full key.

Integrity seal, when enabled:

- `integritySeal32B = Blake3(rowOffsetStream || intCat) (32 bytes)`
- It is appended in encrypted form.

### Mint and Verify mode layout

Mint and Verify ciphertext is:

- `vKeyLock4` plain bytes
- `enc_v(startLocation1Bit)`
- `enc_v(checkpointCount32)`
- `enc_v(signature64) * N`
- `enc_v(intCatLen)`
- `enc_v(intCat)`
- `rowOffsetStream`
- optional: `enc_v(integritySeal32B)`

Where `enc_v(...)` means header mapping that is decryptable by the verifier key.

Notes:

- The verifier-header mapping may use a compact marker encoding for small blobs.
- Authority signatures are ECDSA P-256 in IEEE-P1363 fixed concatenation format (64 bytes).

## Authority checkpoints

Mint and Verify binds provenance by signing a 32-byte **observer state** at one or more checkpoints.

- For payloads up to 4 KiB, RedX uses a single accumulator signature.
- For larger payloads, it computes a checkpoint plan capped by `maxCheckpoints`.

Verification recomputes observer state while replaying the ciphertext walk and requires all signatures to verify before returning plaintext.

## Determinism

Given:

- identical key bytes
- identical `startLocation`
- identical `intCat`

RedX produces identical ciphertext.

In normal use, `startLocation` and `intCat` are randomized per message, which makes ciphertext vary in length and content between encryptions over the same plaintext.

## What to review

If you are reviewing RedX, these are the questions that matter:

- Are there practical distinguishers enabled by the distance stream representation
- Does the jump replay create exploitable structure across positions
- Does the interference catalyst mixing meaningfully reduce replay and structural leakage
- Does Mint and Verify actually enforce origin-locking as intended, or does it collapse under attack
- Is the authority checkpoint design binding the right transcript and at the right granularity

## Non claims

RedX does not claim:

- to be a proven secure cipher
- to replace standardized ciphers
- to be post-quantum secure

## License

Licensed under the Apache License, Version 2.0.
See the LICENSE file for details.

## Build

- .NET 8

```bash
dotnet build
```

